"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tailwindCliV3 = void 0;
exports.tailwindConfigV3 = tailwindConfigV3;
const child_process_1 = require("child_process");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const child_file = __dirname + "/child.js";
const getEnv = (options) => {
    return {
        ...process.env,
        NATIVEWIND_INPUT: options.input,
        NATIVEWIND_OS: options.platform,
        BROWSERSLIST: options.browserslist ?? undefined,
        BROWSERSLIST_ENV: options.browserslistEnv ?? undefined,
    };
};
exports.tailwindCliV3 = {
    processPROD(options) {
        const cliLocation = require.resolve("tailwindcss/lib/cli.js");
        const outputPath = path_1.default.join(path_1.default.dirname(require.resolve("nativewind/package.json")), ".cache/");
        fs_1.default.mkdirSync(outputPath, { recursive: true });
        const output = path_1.default.join(outputPath, `${path_1.default.basename(options.input)}.${options.platform}.css`);
        (0, child_process_1.execSync)(`${cliLocation} --input ${options.input} --output ${output}`, {
            env: getEnv(options),
        });
        return fs_1.default.readFileSync(output);
    },
    processDEV(options) {
        return new Promise((resolve, reject) => {
            try {
                const child = (0, child_process_1.fork)(child_file, { stdio: "pipe", env: getEnv(options) });
                let initialMessage = true;
                let initialDoneIn = true;
                child.stderr?.on("data", (data) => {
                    data = data.toString();
                    if (data.includes("Done in")) {
                        if (initialDoneIn) {
                            initialDoneIn = false;
                        }
                    }
                    else if (data.includes("warn -")) {
                        console.warn(data);
                    }
                });
                child.stdout?.on("data", (data) => {
                    data = data.toString();
                });
                child.on("message", (message) => {
                    if (initialMessage) {
                        resolve(message.toString());
                        initialMessage = false;
                    }
                    else {
                        options.onChange(message.toString());
                    }
                });
            }
            catch (e) {
                reject(e);
            }
        });
    },
};
const flattenPresets = (configs = []) => {
    if (!configs)
        return [];
    return configs.flatMap(config => [
        config,
        ...flattenPresets(config.presets)
    ]);
};
function tailwindConfigV3(path) {
    const config = require("tailwindcss/loadConfig")(path);
    const hasPreset = flattenPresets(config.presets).some((preset) => {
        return preset.nativewind;
    });
    if (!hasPreset) {
        throw new Error("Tailwind CSS has not been configured with the NativeWind preset");
    }
    return config;
}
//# sourceMappingURL=index.js.map