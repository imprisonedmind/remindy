"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTargetValue = getTargetValue;
exports.assignToTarget = assignToTarget;
function getTargetValue(target, config) {
    for (let index = 0; index < config.target.length && target; index++) {
        const prop = config.target[index];
        target = target[prop];
    }
    return target || undefined;
}
function assignToTarget(parent, value, config, { arrayMergeStyle = "push", objectMergeStyle = "assign", allowTransformMerging = false, } = {}) {
    let prop;
    const props = Array.isArray(config) ? config : config.target;
    for (let index = 0; index < props.length - 1; index++) {
        prop = props[index];
        if (Array.isArray(parent) && isFinite(Number(prop))) {
            prop = Number(prop);
        }
        if (typeof parent[prop] !== "object") {
            parent[prop] = {};
        }
        parent = parent[prop];
    }
    prop = props[props.length - 1];
    if (allowTransformMerging && transformKeys.has(prop)) {
        let existing;
        if (!Array.isArray(parent.transform)) {
            parent.transform = [];
        }
        else {
            existing = parent.transform.find((t) => prop in t);
        }
        if (existing) {
            existing[prop] = value;
        }
        else {
            parent.transform.push({ [prop]: value });
        }
    }
    else {
        const target = parent[prop];
        if (Array.isArray(target)) {
            switch (arrayMergeStyle) {
                case "push":
                    target.push(value);
            }
        }
        else if (typeof target === "object" && target) {
            switch (objectMergeStyle) {
                case "assign": {
                    if (typeof value === "object") {
                        parent[prop] = Object.assign({}, parent[prop], value);
                    }
                    else {
                        parent[prop] = value;
                    }
                    break;
                }
                case "toArray": {
                    parent[prop] = [target, value];
                }
            }
        }
        else {
            parent[prop] = value;
        }
    }
}
const transformKeys = new Set([
    "transform",
    "translateX",
    "translateY",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skewX",
    "skewY",
    "perspective",
    "matrix",
    "transformOrigin",
]);
//# sourceMappingURL=utils.js.map