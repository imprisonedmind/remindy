"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withCssInterop = withCssInterop;
const connect_1 = __importDefault(require("connect"));
const promises_1 = __importDefault(require("fs/promises"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const expo_1 = require("./expo");
const css_to_rn_1 = require("../css-to-rn");
const shared_1 = require("./shared");
let haste;
const virtualModules = new Map();
function withCssInterop(config, { platforms = ["ios", "android", "web", "native"], ...options }) {
    (0, expo_1.expoColorSchemeWarning)();
    const originalResolver = config.resolver?.resolveRequest;
    const originalMiddleware = config.server?.enhanceMiddleware;
    const prodOutputDir = path_1.default.join(path_1.default.dirname(require.resolve("react-native-css-interop/package.json")), ".cache");
    fs_1.default.mkdirSync(prodOutputDir, { recursive: true });
    for (const platform of platforms) {
        fs_1.default.writeFileSync(path_1.default.join(prodOutputDir, `${platform}.${platform === "web" ? "css" : "js"}`), "");
    }
    return {
        ...config,
        transformer: {
            ...config.transformer,
            async getTransformOptions(entryPoints, transformOptions, getDependenciesOf) {
                if (!transformOptions.dev) {
                    const platform = transformOptions.platform || "native";
                    await promises_1.default.mkdir(prodOutputDir, { recursive: true });
                    if (platform === "web") {
                        const output = path_1.default.join(prodOutputDir, `web.css`);
                        await promises_1.default.writeFile(output, options.processPROD(platform));
                    }
                    else {
                        const output = path_1.default.join(prodOutputDir, `${platform}.js`);
                        await promises_1.default.writeFile(output, (0, shared_1.getNativeJS)((0, css_to_rn_1.cssToReactNativeRuntime)(options.processPROD(platform), options)));
                    }
                }
                return (config.transformer?.getTransformOptions?.(entryPoints, transformOptions, getDependenciesOf) || {});
            },
        },
        server: {
            ...config.server,
            enhanceMiddleware: (middleware, metroServer) => {
                const server = (0, connect_1.default)();
                const bundler = metroServer.getBundler().getBundler();
                const initPromise = bundler
                    .getDependencyGraph()
                    .then(async (graph) => {
                    haste = graph._haste;
                    ensureFileSystemPatched(graph._fileSystem);
                    ensureBundlerPatched(bundler);
                });
                server.use(async (_, __, next) => {
                    await initPromise;
                    next();
                });
                return originalMiddleware
                    ? server.use(originalMiddleware(middleware, metroServer))
                    : server.use(middleware);
            },
        },
        resolver: {
            ...config.resolver,
            sourceExts: [...(config?.resolver?.sourceExts || []), "css"],
            resolveRequest: (context, moduleName, platform) => {
                const resolver = originalResolver ?? context.resolveRequest;
                const resolved = resolver(context, moduleName, platform);
                if (!("filePath" in resolved && resolved.filePath === options.input)) {
                    return resolved;
                }
                platform = platform || "native";
                const isDev = context.dev;
                if (isDev) {
                    const platformFilePath = (0, shared_1.platformPath)(resolved.filePath, platform);
                    startCSSProcessor(platformFilePath, platform, options, true);
                    return {
                        ...resolved,
                        filePath: platformFilePath,
                    };
                }
                else {
                    return resolver(context, path_1.default.join("react-native-css-interop", ".cache", platform), platform);
                }
            },
        },
    };
}
async function startCSSProcessor(filePath, platform, { input, processDEV, ...options }, dev) {
    if (virtualModules.has(filePath)) {
        return;
    }
    const virtualStyles = processDEV(platform, (css) => {
        virtualModules.set(filePath, Promise.resolve(platform === "web"
            ? Buffer.from(css)
            : (0, shared_1.getNativeJS)((0, css_to_rn_1.cssToReactNativeRuntime)(css, options), dev)));
        haste.emit("change", {
            eventsQueue: [
                {
                    filePath,
                    metadata: {
                        modifiedTime: Date.now(),
                        size: 1,
                        type: "virtual",
                    },
                    type: "change",
                },
            ],
        });
    }).then((css) => {
        return platform === "web"
            ? Buffer.from(css)
            : (0, shared_1.getNativeJS)((0, css_to_rn_1.cssToReactNativeRuntime)(css, options), dev);
    });
    virtualModules.set(filePath, virtualStyles);
}
function ensureFileSystemPatched(fs) {
    if (!fs.getSha1.__css_interop_patched) {
        const original_getSha1 = fs.getSha1.bind(fs);
        fs.getSha1 = (filename) => {
            if (virtualModules.has(filename)) {
                return `${filename}-${Date.now()}`;
            }
            return original_getSha1(filename);
        };
        fs.getSha1.__css_interop_patched = true;
    }
    return fs;
}
function ensureBundlerPatched(bundler) {
    if (bundler.transformFile.__css_interop__patched) {
        return;
    }
    const originalTransformFile = bundler.transformFile.bind(bundler);
    bundler.transformFile = async function (filePath, transformOptions, fileBuffer) {
        const virtualModule = virtualModules.get(filePath);
        if (virtualModule) {
            fileBuffer = await virtualModule;
        }
        return originalTransformFile(filePath, transformOptions, fileBuffer);
    };
    bundler.transformFile.__css_interop__patched = true;
}
//# sourceMappingURL=index.js.map